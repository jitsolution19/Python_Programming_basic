// Generated by CoffeeScript 1.6.2
/*
jQuery Waypoints - v2.0.3
Copyright (c) 2011-2013 Caleb Troughton
Dual licensed under the MIT license and GPL license.
https://github.com/imakewebthings/jquery-waypoints/blob/master/licenses.txt
*/
$(function () {
    var indexOf = [].indexOf || function (t) {
        for (var e = 0, n = this.length; e < n; e++) {
            if (e in this && this[e] === t) return e;
        }
        return -1;
    };
    var slice = [].slice;

    (function (t, e) {
        if (typeof define === "function" && define.amd) {
            return define("waypoints", ["jquery"], function (n) {
                return e(n, t);
            });
        } else {
            return e(t.jQuery, t);
        }
    })(this, function ($, window) {
        var Waypoint, Context, methods, internalMethods;

        var $window = $(window);
        var isTouch = indexOf.call(window, "ontouchstart") >= 0;

        // Context class definition
        Context = function (element) {
            this.$element = $(element);
            this.element = element;
            this.didResize = false;
            this.didScroll = false;
            this.id = "context" + Context.counter++;
            this.oldScroll = {
                x: this.$element.scrollLeft(),
                y: this.$element.scrollTop()
            };
            this.waypoints = {
                horizontal: {},
                vertical: {}
            };
            this.$element.data(Context.dataKey, this.id);
            Context.instances[this.id] = this;

            this.$element.bind('scroll.waypoints', function () {
                if (!this.didScroll && !isTouch) {
                    this.didScroll = true;
                    window.setTimeout(function () {
                        this.doScroll();
                        this.didScroll = false;
                    }.bind(this), $.waypoints.settings.scrollThrottle);
                }
            }.bind(this));

            this.$element.bind('resize.waypoints', function () {
                if (!this.didResize) {
                    this.didResize = true;
                    window.setTimeout(function () {
                        $.waypoints('refresh');
                        this.didResize = false;
                    }.bind(this), $.waypoints.settings.resizeThrottle);
                }
            }.bind(this));
        };

        Context.counter = 1;
        Context.dataKey = 'waypoints-context-id';
        Context.instances = {};

        Context.prototype.doScroll = function () {
            var scrollData = {
                horizontal: {
                    newScroll: this.$element.scrollLeft(),
                    oldScroll: this.oldScroll.x,
                    forward: 'right',
                    backward: 'left'
                },
                vertical: {
                    newScroll: this.$element.scrollTop(),
                    oldScroll: this.oldScroll.y,
                    forward: 'down',
                    backward: 'up'
                }
            };

            if (isTouch && (!scrollData.vertical.oldScroll || !scrollData.vertical.newScroll)) {
                $.waypoints('refresh');
            }

            $.each(scrollData, function (axis, data) {
                var direction, waypoints, triggeredWaypoints;
                waypoints = this.waypoints[axis];
                direction = data.newScroll > data.oldScroll ? data.forward : data.backward;
                triggeredWaypoints = [];

                $.each(waypoints, function (waypointKey, waypoint) {
                    var wasBeforeScroll = data.oldScroll < waypoint.offset;
                    var nowAfterScroll = data.newScroll >= waypoint.offset;
                    if (wasBeforeScroll && nowAfterScroll) {
                        triggeredWaypoints.push(waypoint);
                    } else if (!wasBeforeScroll && data.newScroll <= waypoint.offset) {
                        triggeredWaypoints.push(waypoint);
                    }
                });

                triggeredWaypoints.sort(function (a, b) {
                    return a.offset - b.offset;
                });

                if (direction === data.backward) {
                    triggeredWaypoints.reverse();
                }

                $.each(triggeredWaypoints, function (i, waypoint) {
                    if (waypoint.options.continuous || i === triggeredWaypoints.length - 1) {
                        waypoint.trigger([direction]);
                    }
                });
            }.bind(this));

            this.oldScroll = {
                x: scrollData.horizontal.newScroll,
                y: scrollData.vertical.newScroll
            };
        };

        Context.prototype.refresh = function () {
            var isWindow = $.isWindow(this.element);
            var contextOffset = isWindow ? 0 : this.$element.offset();

            var scrollData = {
                horizontal: {
                    contextOffset: contextOffset.left,
                    contextScroll: this.oldScroll.x,
                    contextDimension: this.$element.width(),
                    oldScroll: this.oldScroll.x,
                    forward: 'right',
                    backward: 'left',
                    offsetProp: 'left'
                },
                vertical: {
                    contextOffset: contextOffset.top,
                    contextScroll: this.oldScroll.y,
                    contextDimension: isWindow ? $.waypoints('viewportHeight') : this.$element.height(),
                    oldScroll: this.oldScroll.y,
                    forward: 'down',
                    backward: 'up',
                    offsetProp: 'top'
                }
            };

            this.doScroll();

            $.each(scrollData, function (axis, data) {
                $.each(this.waypoints[axis], function (waypointKey, waypoint) {
                    var adjustment, offset, base, offsetPercentage;

                    adjustment = waypoint.options.offset;
                    base = waypoint.offset;

                    offset = $.isWindow(waypoint.element) ? 0 : $(waypoint.element).offset()[data.offsetProp];
                    if ($.isFunction(adjustment)) {
                        adjustment = adjustment.apply(waypoint.element);
                    } else if (typeof adjustment === 'string') {
                        adjustment = parseFloat(adjustment);
                        if (waypoint.options.offset.indexOf('%') > -1) {
                            offsetPercentage = adjustment / 100;
                            adjustment = Math.ceil(data.contextDimension * offsetPercentage);
                        }
                    }

                    waypoint.offset = offset - data.contextOffset + data.contextScroll - adjustment;

                    if (waypoint.options.onlyOnScroll && base !== null || !waypoint.enabled) {
                        return;
                    }

                    if (base !== null && base < data.oldScroll && data.oldScroll <= waypoint.offset) {
                        waypoint.trigger([data.backward]);
                    } else if (base !== null && base > data.oldScroll && data.oldScroll >= waypoint.offset) {
                        waypoint.trigger([data.forward]);
                    } else if (base === null && data.oldScroll >= waypoint.offset) {
                        waypoint.trigger([data.forward]);
                    }
                });
            }.bind(this));
        };

        Context.prototype.checkEmpty = function () {
            if ($.isEmptyObject(this.waypoints.horizontal) && $.isEmptyObject(this.waypoints.vertical)) {
                this.$element.unbind('resize.waypoints scroll.waypoints');
                delete Context.instances[this.id];
            }
        };

        // Waypoint class definition
        Waypoint = function (element, context, options) {
            var base, previousOffset, callbacks;

            options = $.extend({}, $.fn.waypoint.defaults, options);

            if (options.offset === 'bottom-in-view') {
                options.offset = function () {
                    var contextHeight = $.waypoints('viewportHeight');
                    if (!$.isWindow(context.element)) {
                        contextHeight = context.$element.height();
                    }
                    return contextHeight - $(this).outerHeight();
                };
            }

            this.$element = $(element);
            this.element = element;
            this.axis = options.horizontal ? 'horizontal' : 'vertical';
            this.callback = options.handler;
            this.context = context;
            this.enabled = options.enabled;
            this.id = 'waypoints' + Waypoint.counter++;
            this.offset = null;
            this.options = options;
            context.waypoints[this.axis][this.id] = this;
            Context.waypoints[this.axis][this.id] = this;

            base = (previousOffset = element.data(Context.dataKey)) != null ? previousOffset : [];
            base.push(this.id);
            element.data(Context.dataKey, base);
        };

        Waypoint.counter = 1;

        Waypoint.prototype.trigger = function (args) {
            if (!this.enabled) {
                return;
            }
            if (this.callback != null) {
                this.callback.apply(this.element, args);
            }
            if (this.options.triggerOnce) {
                this.destroy();
            }
        };

        Waypoint.prototype.disable = function () {
            this.enabled = false;
        };

        Waypoint.prototype.enable = function () {
            this.context.refresh();
            this.enabled = true;
        };

        Waypoint.prototype.destroy = function () {
            delete Context.waypoints[this.axis][this.id];
            delete this.context.waypoints[this.axis][this.id];
            this.context.checkEmpty();
        };

        Waypoint.getWaypointsByElement = function (element) {
            var base, waypoints;
            waypoints = $(element).data(Context.dataKey);
            if (!waypoints) {
                return [];
            }
            base = $.extend({}, Context.waypoints.horizontal, Context.waypoints.vertical);
            return $.map(waypoints, function (key) {
                return base[key];
            });
        };

        // Plugin definition
        methods = {
            init: function (handler, options) {
                var context;

                if (options == null) {
                    options = {};
                }

                if ((context = options.handler) == null) {
                    options.handler = handler;
                }

                this.each(function () {
                    var context, element, contextElement, contextData;

                    contextElement = $(this);
                    context = options.context != null ? options.context : $.fn.waypoint.defaults.context;
                    if (!$.isWindow(context)) {
                        context = contextElement.closest(context);
                    }
                    context = $(context);
                    contextData = Context.instances[context.data(Context.dataKey)];
                    if (!contextData) {
                        contextData = new Context(context);
                    }
                    new Waypoint(contextElement, contextData, options);
                });

                $.waypoints('refresh');
                return this;
            },
            disable: function () {
                return methods._invoke(this, 'disable');
            },
            enable: function () {
                return methods._invoke(this, 'enable');
            },
            destroy: function () {
                return methods._invoke(this, 'destroy');
            },
            prev: function (axis, selector) {
                return methods._traverse.call(this, axis, selector, function (waypoints, index, allWaypoints) {
                    if (index > 0) {
                        return waypoints.push(allWaypoints[index - 1]);
                    }
                });
            },
            next: function (axis, selector) {
                return methods._traverse.call(this, axis, selector, function (waypoints, index, allWaypoints) {
                    if (index < allWaypoints.length - 1) {
                        return waypoints.push(allWaypoints[index + 1]);
                    }
                });
            },
            _traverse: function (axis, selector, method) {
                var allWaypoints, waypoints;

                if (axis == null) {
                    axis = 'vertical';
                }
                if (selector == null) {
                    selector = window;
                }
                allWaypoints = Waypoint.aggregate(selector);
                waypoints = [];

                this.each(function () {
                    var index;

                    index = $.inArray(this, allWaypoints[axis]);
                    method(waypoints, index, allWaypoints[axis]);
                });

                return this.pushStack(waypoints);
            },
            _invoke: function (elements, methodName) {
                elements.each(function () {
                    var waypoints;

                    waypoints = Waypoint.getWaypointsByElement(this);
                    $.each(waypoints, function (index, waypoint) {
                        waypoint[methodName]();
                        return true;
                    });
                });
                return this;
            }
        };

        $.fn.waypoint = function () {
            var method, args;

            method = arguments[0];
            args = 2 <= arguments.length ? slice.call(arguments, 1) : [];

            if (methods[method]) {
                return methods[method].apply(this, args);
            } else if ($.isFunction(method)) {
                return methods.init.apply(this, arguments);
            } else if ($.isPlainObject(method)) {
                return methods.init.apply(this, [null, method]);
            } else if (!method) {
                return $.error("jQuery Waypoints needs a callback function or handler option.");
            } else {
                return $.error("The " + method + " method does not exist in jQuery Waypoints.");
            }
        };

        $.fn.waypoint.defaults = {
            context: window,
            continuous: true,
            enabled: true,
            horizontal: false,
            offset: 0,
            triggerOnce: false
        };

        internalMethods = {
            refresh: function () {
                $.each(Context.instances, function (key, context) {
                    context.refresh();
                });
            },
            viewportHeight: function () {
                return window.innerHeight || $window.height();
            },
            aggregate: function (selector) {
                var waypoints, contexts;

                waypoints = Waypoint.aggregate(selector);
                contexts = [];

                $.each(contexts, function (axis, waypointCollection) {
                    $.each(Waypoint.instances[axis], function (key, waypoint) {
                        waypointCollection.push(waypoint);
                    });
                    waypointCollection.sort(function (a, b) {
                        return a.offset - b.offset;
                    });
                    contexts[axis] = $.map(waypointCollection, function (waypoint) {
                        return waypoint.element;
                    });
                    contexts[axis] = $.unique(contexts[axis]);
                });

                return contexts;
            },
            above: function (context) {
                return internalMethods._filter(context, 'vertical', function (context, waypoint) {
                    return waypoint.offset <= context.oldScroll.y;
                });
            },
            below: function (context) {
                return internalMethods._filter(context, 'vertical', function (context, waypoint) {
                    return waypoint.offset > context.oldScroll.y;
                });
            },
            left: function (context) {
                return internalMethods._filter(context, 'horizontal', function (context, waypoint) {
                    return waypoint.offset <= context.oldScroll.x;
                });
            },
            right: function (context) {
                return internalMethods._filter(context, 'horizontal', function (context, waypoint) {
                    return waypoint.offset > context.oldScroll.x;
                });
            },
            enable: function () {
                return internalMethods._invoke('enable');
            },
            disable: function () {
                return internalMethods._invoke('disable');
            },
            destroy: function () {
                return internalMethods._invoke('destroy');
            },
            extendFn: function (methodName, method) {
                return methods[methodName] = method;
            },
            _invoke: function (methodName) {
                var allWaypoints;

                allWaypoints = $.extend({}, Waypoint.instances.vertical, Waypoint.instances.horizontal);
                $.each(allWaypoints, function (key, waypoint) {
                    waypoint[methodName]();
                    return true;
                });
            },
            _filter: function (context, axis, test) {
                var contextInstance, waypoints;

                contextInstance = Context.instances[$(context).data(Context.dataKey)];
                if (!contextInstance) {
                    return [];
                }
                waypoints = [];

                $.each(contextInstance.waypoints[axis], function (key, waypoint) {
                    if (test(contextInstance, waypoint)) {
                        waypoints.push(waypoint);
                    }
                });

                waypoints.sort(function (a, b) {
                    return a.offset - b.offset;
                });

                return $.map(waypoints, function (waypoint) {
                    return waypoint.element;
                });
            }
        };

        $.waypoints = function () {
            var method, args;

            method = arguments[0];
            args = 2 <= arguments.length ? slice.call(arguments, 1) : [];

            if (internalMethods[method]) {
                return internalMethods[method].apply(null, args);
            } else {
                return internalMethods.aggregate.call(null, method);
            }
        };

        $.waypoints.settings = {
            resizeThrottle: 100,
            scrollThrottle: 30
        };

        $window.load(function () {
            $.waypoints('refresh');
        });
    });
});